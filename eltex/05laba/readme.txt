## Создание статической библиотеки

Для создания статической библиотеки в исходный код программы её использующую
необходимо добавить загловочный файл, описывающий функции библиотеки, или
описать их как extern:

#include <stdio.h>
...
extern void func();

int main() {
  ...
  void func();
  ...
  return 0;
}

Создаем исходные коды будущей библиотеки, например:

/* file1.c */
void func1() {
  printf("func1\n");
}

/* file2.c */
void func2() {
  printf("func2\n");
}

После их необходимо скомпилировать в объектные файлы *.o:

 $ gcc -c file1.c file2.c

Затем при помощи утилиты ar запаковать в библиотеку:

 $ ar rc libmylib.a file1.o file2.o

ключи -r (replace) -c (create)

Затем необходимо добавить индекс символов, чтобы из полученного архива вышла
полноценная библиотека:

 $ ranlib libmylib.a

И завершающий этап - компиляция с исользованием полученной статической
библиотеки, программы:

 $ gcc main.c -L. -lmylib -o main

ключи -L - указывает расположение библиотеки,
      -l - указывает имя библиотеки без префикса и окончания
      -o - указывает имя выходного файла

Программа готова.

## Создание динамической библиотеки

В отличие от создания статической библиотеки, для динамической библиотеки
необходимо подготовить объектные файлы будущей библиотеки скомпилировав их с
ключём -fPIC, это нужно для того чтобы программа использующая динамическую
библиотеку могла получить адрес функций динамически, во время работы программы.
 
 $ gcc -fPIC -c file1.c file2.c

ключи -fPIC Position Independent Code, все объектные файлы создаваемые обычным
образом не имеют представления о том в какие адреса памяти будет загружена
использующая их программа. Несколько различных программ могут использовать одну
библиотеку, и каждая из них располагается в различном адресном пространстве. 
переходы в функциях библиотеки (операции goto на ассемблере) использовали не 
абсолютную адресацию, а относительную. То есть генерируемый компилятором код 
должен быть независимым от адресов, такая технология получила название PIC - 
Position Independent Code.

Динамическая библиотека это уже не просто архив объектных файлов, а полноценная
программа на Си, поэтому для её создания необходимо использовать не архиватор, а
компилятор.
 
 $ gcc -shared -o libmylib.so file1.o file2.o

ключи -shared - указывает компилятору, что создается динамическая библиотека

Для компиляции программы использующую такую библиотеку необходима следующая
команда:
 
 $ gcc main.c -L. -lmylib -o main

которая ничем не отличается от той которую использовали при создании статической
библиотеки.

Однако, если запустить такую программу то получим ошибку, что-то вроде этой:

 ./main: error while loading shared libraries: libmylib.so: cannot open shared
 object file: No such file or directory

Это произошло потому, что динамический линковщик не может найти нашу библиотеку,
потому что не знает где искать. Обычные места для хранения таких библиотек /lib
/usr/lib иногда /usr/local/lib. Для того, что бы линковщик знал где брать нужную
библиотеку есть 2 способа указания:

 1. С помощью ключей -Wl,-rpath,. на этапе компиляции исполняемого файла, где .
 указывает на относительный путь, т.е. текущий каталог. Если запустить программу
 откуда-то из другого каталога, то получим ошибку, т.к. в том другом месте нет
 нашей библиотеки.

 2. С помощью переменной окружения LD_LIBRARY_PATH, в которую можно указать как
 полный, так и относительный путь. Рекомендуется использовать полный путь к
 каталогу с библиотекой. Например:
  
  $ echo $LD_LIBRARY_PATH // просмотреть что находится в переменной
  $ export LD_LIBRARY_PATH=/path/to/libdir
 
 В случае, если у Вас в системе эта переменная среды уже уставновлена, то, чтобы
 не испортить ее значение, надо новый каталог прибавить к старому значению.
 Делается это другой командой: 
  
  $ export LD_LIBRARY_PATH=/path/to/libdir:${LD_LIBRARY_PATH}

Что бы узнать какие библиотеки используются программой можно воспользоваться
утилитой ldd:
 
 $ ldd [PROGRAM_NAME]

До сих пор использовалась динамическая библиотека как статическая. Т.е. все
функции загружались в начале работы программы. Однако приемущество в
динамических библиотек в том, что функции из них можно вызывать когда угодно в
программе. Для этого необходимо использовать библиотеку dl, которая позволяет
линковать библиотеки "на лету". Она управляет загрузкой динамических библиотек,
вызовом функций из них и выгрузкой после конца работы. 

Для её использования необходимо подключить заголовочный файл:

#include <dlfcn.h>

Для того что бы вызывать ф-ии из библиотеки, её необходимо открыть. На подобие с
файлом:

void *dlopen (const char *filename, int flag);

  filename - путь к библиотеке
  flag - задает некоторые специфически флаги для работы с библиотекой.

Функция возвращает указатель на открытую библиотеку, в случае ошибки - NULL. 

Чтобы получить адрес ф-ии небходимо дать её имя функции dlsym:

void *dlsym (void *handle, char *symbol);

handle - указатель полученный во время открытия библиотеки функцией dlopen().

По окончании работы с библиотекой её необходимо закрыть при помощи функции
dlclose(void *handle);

При закрытии библиотеки динамический линковщик проверяет счетчик количества
открытий библиотеки, и если она была открыта несколькими программами
одновременно, то она не выгружается до тех пор, пока все программы не закроют
эту библиотеку.
